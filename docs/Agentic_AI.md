## 에이전틱 AI(Agentic AI) 기술 개요 및 워크플로우 (최종본)
1. 에이전틱 AI 정의 🤖

에이전틱 AI는 주어진 목표(Goal)를 달성하기 위해 자율적으로(Autonomously) 상황을 **인식(Perception)**하고, **계획을 수립(Planning)**하며, 다양한 **도구(Tools)**를 사용하여 계획을 **실행(Execution)**하고, 그 결과를 **스스로 평가 및 수정(Reflection & Adaptation)**하는 능력을 갖춘 AI 시스템입니다. 핵심은 목표 지향적 자율성에 기반한 동적인 과업 수행 능력입니다.

2. 최신 연구 및 개발 트렌드 📈

멀티 에이전트 시스템 (Multi-Agent Systems): 단일의 거대 모델이 모든 과업을 처리하는 대신, 특정 기능에 특화된 여러 에이전트가 상호작용하며 복잡한 문제를 해결하는 아키텍처가 주류가 되고 있습니다.

도메인 특화 (Domain-Specific Specialization): 범용 에이전트보다 특정 산업(금융, 의료, 법률 등)의 데이터와 워크플로우에 맞춰 미세조정(Fine-tuning)된 에이전트가 더 높은 정확도와 신뢰성을 보이며 활발히 연구되고 있습니다.

동적 도구 사용 및 통합 (Dynamic Tool Use & Integration): 정적으로 정의된 도구 세트 외에, 에이전트가 실행 시점에서 필요한 외부 API나 라이브러리를 동적으로 찾고 학습하여 활용하는 기술이 중요해지고 있습니다.

3. 핵심 아키텍처 및 워크플로우 (실제 구현 사례 기반)

에이전틱 AI의 작동은 크게 기본 실행 루프와 이 루프를 기반으로 복잡한 작업을 처리하는 멀티-툴 오케스트레이션으로 나눌 수 있습니다.

(1) 기본 실행 루프 (Core Execution Loop): ReAct

에이전트의 모든 자율적 행동은 ReAct (Reasoning and Acting) 라는 핵심 실행 루프를 통해 이루어집니다. 이는 단순히 LLM을 한 번 호출하고 끝나는 것이 아니라, [사고 → 행동 → 관찰] 이라는 체계적인 사이클을 목표가 달성될 때까지 반복하며 점진적으로 문제를 해결해 나가는 동적인 프로세스입니다.

ReAct 루프의 상세 동작 원리

하나의 ReAct 사이클은 다음과 같은 5단계로 매우 세밀하게 나누어 볼 수 있습니다.

프롬프트 구성 (Prompt Assembly):

루프가 시작될 때, 에이전트 실행기(Agent Executor)는 LLM에 전달할 프롬프트를 동적으로 구성합니다. 이 프롬프트에는 다음과 같은 정보가 모두 포함됩니다.

시스템 프롬프트: 에이전트의 정체성, 목표, 규칙, 사용 가능한 도구 목록 및 스키마.

사용자 입력: 사용자가 최초에 요청한 원본 과제.

대화 히스토리: 이전 턴에서 나눈 대화 기록 (있는 경우).

중간 과정 (Agent Scratchpad): (가장 중요) 이전 사이클들에서 수행했던 [사고 → 행동 → 관찰]의 모든 기록. 이 기록을 통해 LLM은 자신이 이전에 무슨 일을 했고 그 결과가 어땠는지 파악할 수 있습니다.

추론 (Reasoning - "Re"):

구성된 프롬프트를 받은 LLM은 가장 먼저 **사고(Thought)**를 생성합니다.

이 단계에서 LLM은 "현재 상황이 어떻고, 최종 목표를 달성하기 위해 다음 단계로 무엇을 해야 할까?"를 스스로에게 질문하고 그에 대한 논리적인 계획을 텍스트로 정리합니다. 이는 LLM의 내부적인 문제 해결 과정을 보여주는 단계입니다.

행동 결정 (Action - "Act"):

'사고'를 바탕으로 LLM은 구체적인 **행동(Action)**을 결정합니다. 이 행동은 대부분 특정 도구를 호출하는 형태로 나타납니다.

출력 형식은 보통 JSON 형태이며, {"tool": "도구_이름", "tool_input": "도구에_전달할_인자"}와 같이 호출할 도구의 이름과 그에 필요한 입력값을 명확하게 지정합니다. 만약 모든 과업이 끝났다고 판단하면, 최종 답변을 생성하는 FinalAnswer와 같은 특별한 행동을 결정하기도 합니다.

행동 실행 및 관찰 (Execution & Observation):

LLM이 '행동'을 출력하면, 에이전트 실행기는 이 출력을 파싱합니다.

실행기는 지정된 도구_이름에 해당하는 실제 함수(Python 함수)를 도구에_전달할_인자와 함께 호출합니다.

함수 실행 후 반환된 결과(성공 데이터, 오류 메시지 등)가 바로 관찰(Observation) 결과가 됩니다.

다음 루프 준비:

실행기는 방금 수행한 [행동 + 관찰] 결과를 '중간 과정(Agent Scratchpad)'에 추가로 기록합니다.

이후, 업데이트된 '중간 과정'을 포함하여 1단계부터 다시 루프를 시작합니다. 이 과정은 LLM이 최종 답변(FinalAnswer)을 생성할 때까지 계속 반복됩니다.

실제 CLI 도구에서의 구현 사례

Codex CLI (Rust): run_turn 함수가 이 ReAct 사이클 한 번을 처리하는 역할을 합니다. prompt.md라는 시스템 프롬프트를 통해 LLM이 "Thought"와 "Action"을 텍스트 형식으로 출력하도록 유도하고, 실행기는 이 텍스트를 파싱하여 도구를 실행하는 고전적인 방식을 사용합니다.

Gemini CLI (TypeScript): 텍스트 템플릿에 의존하기보다 모델의 네이티브 기능(Function Calling)을 적극 활용합니다. Turn.run()은 모델이 스트리밍으로 반환하는 구조화된 이벤트(Thought 파트, ToolCallRequest)를 직접 처리합니다. 즉, LLM이 생각과 행동을 정해진 JSON 객체로 반환하면, 실행기는 이를 해석하여 루프를 진행시키는 더 현대적인 방식을 사용합니다.

Python (LangChain)에서의 구현

Python에서는 이 복잡한 루프를 직접 코딩할 필요가 없습니다. LangChain의 Agent Executor가 모든 과정을 추상화하여 제공합니다.

개발자는 ChatPromptTemplate을 사용하여 프롬프트를 정의하는데, 이때 {agent_scratchpad} 라는 특수한 변수를 포함시키기만 하면 됩니다.

Agent Executor는 루프를 돌 때마다 자동으로 [행동 -> 관찰] 기록을 이 {agent_scratchpad} 변수에 채워서 다음 LLM 호출 시 전달합니다.

따라서 개발자는 루프의 상세 로직이 아닌, 어떤 도구를 제공할지와 어떤 프롬프트를 통해 에이전트의 추론 능력을 극대화할지에만 집중할 수 있습니다.

(2) 멀티-툴 오케스트레이션 (Multi-Tool Orchestration)

하나의 목표를 위해 여러 도구를 복합적으로 사용하는 워크플로우이며, 실제 서비스에서는 다음과 같은 핵심 요소들로 구현됩니다.

상태 관리 (State Management):

개념: 에이전트는 루프를 반복하며 대화 히스토리, 이전 도구 실행 결과, 현재 계획 등 컨텍스트를 유지해야 합니다.

구현 사례:

Codex CLI는 Session 객체 내에 State 구조체를 두어 승인된 명령어, 히스토리, 토큰 사용량 등 모든 상태를 중앙에서 관리합니다.

Gemini CLI는 GeminiClient(대화 히스토리), Turn(현재 턴의 상태), CoreToolScheduler(도구 실행 상태) 등 여러 **상태 저장 서비스 객체(Stateful Service Objects)**에 상태를 분산하여 관리합니다.

도구 정의 및 라우팅 (Tool Definition & Routing):

개념: 에이전트가 사용 가능한 도구의 기능과 인자를 이해하고, 모델의 도구 사용 요청을 실제 함수 호출로 연결하는 메커니즘입니다.

구현 사례:

정의: Codex CLI는 **ToolsConfig**를 통해, Gemini CLI는 DeclarativeTool 클래스 패턴을 통해 도구를 정의합니다. 두 경우 모두 모델이 이해할 수 있도록 JSON Schema를 사용합니다.

등록: Codex는 설정 기반, Gemini는 **ToolRegistry**에 도구를 등록하여 관리합니다.

라우팅: Codex는 handle_response_item 함수가, Gemini는 CoreToolScheduler가 모델의 도구 호출 요청을 받아 적절한 함수를 실행하는 라우터 역할을 합니다.

계획 수립 및 동적 수정 (Planning & Dynamic Adaptation):

개념: 초기 목표를 달성하기 위한 계획을 세우고, 실행 중 발생하는 오류나 예상치 못한 결과에 대응하여 계획을 수정하는 능력입니다.

구현 사례:

계획: Codex CLI는 update_plan이라는 특수 도구를 통해 모델이 직접 계획을 생성하고 업데이트할 수 있습니다. 반면, Gemini CLI는 명시적인 계획 없이 매 턴마다 다음 행동을 결정하는 순수한 ReAct 방식을 따릅니다.

오류 처리 및 적응: Codex는 API 실패 시 지수 백오프로 재시도합니다. Gemini는 선형 백오프 재시도는 물론, **LoopDetectionService**라는 특화된 서비스를 두어 반복적인 도구 호출과 같은 무한 루프를 감지하고 실행을 동적으로 차단합니다.

4. 프롬프트 엔지니어링 실제 구현 ✍️

중앙화된 시스템 프롬프트: 에이전트의 정체성, 규칙, 능력 등은 코드와 분리된 중앙 프롬프트 파일에 정의됩니다.

Codex CLI: prompt.md 파일이 에이전트의 모든 행동 기반이 되는 시스템 프롬프트 역할을 합니다.

Gemini CLI: getCoreSystemPrompt() 함수가 GEMINI_SYSTEM_MD 환경 변수로 지정된 파일이나 기본 시스템 프롬프트를 로드하여 사용합니다.

동적 프롬프트 구성: 매 턴마다 기본 시스템 프롬프트에 대화 히스토리, 사용 가능한 도구 목록, 추가 컨텍스트(IDE 상태 등)를 동적으로 결합하여 최종 프롬프트를 생성합니다.

5. 대표적인 아키텍처 및 기술 스택 비교 🔬

항목	Codex CLI	Gemini CLI
언어/런타임	Rust	TypeScript / Node.js
오케스트레이션	자체 구현 (Rust 비동기 기본 요소 활용)	서비스 기반 (이벤트 지향, 특화 서비스 객체)
상태 관리	중앙 집중식 (Session 객체)	분산형 (여러 서비스 객체에 분산)
핵심 의존성	tokio, reqwest, serde	@google/genai, @modelcontextprotocol/sdk
주요 디자인 패턴	계층형 아키텍처, 커맨드 패턴	옵저버/이벤트 기반, 전략 패턴, 상태 저장 서비스
6. 결론 및 핵심 디자인 패턴 🏛️

에이전틱 AI는 ReAct 실행 루프, 상태 관리, 동적 도구 라우팅이라는 공통된 핵심 요소를 가집니다. 하지만 실제 구현에서는 Codex CLI처럼 Rust의 강력한 비동기 기능을 활용해 자체적으로 오케스트레이션을 구축하는 방식과, Gemini CLI처럼 TypeScript 생태계에서 이벤트 기반의 특화된 서비스 객체들로 역할을 분담하는 방식 등 다양한 아키텍처 선택이 가능합니다.

성공적인 에이전틱 AI를 구축하기 위해서는 다음과 같은 디자인 패턴을 고려하는 것이 유용합니다.

커맨드 패턴 (Command Pattern): 도구의 정의와 실행을 캡슐화합니다.

옵저버 패턴 (Observer Pattern): 모델의 스트리밍 출력을 이벤트로 처리하여 비동기적인 흐름을 관리합니다.

전략 패턴 (Strategy Pattern): 재시도 정책이나 모델 선택 로직을 유연하게 교체할 수 있도록 합니다.