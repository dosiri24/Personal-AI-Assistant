# 개인 AI 비서 프로젝트

## 📋 프로젝트 개요

**프로젝트명**: Personal AI Assistant  
**목표**: Discord를 통해 자연어 명령을 받아 에이전틱 AI가 스스로 판단하고 MCP 도구를 활용하여 임무를 완수하는 지능형 개인 비서  
**핵심 개념**: 
- **에이전틱 AI**: LLM이 직접 자연어를 이해하고 도구를 선택 (중간 분류/파싱 과정 제거)
- **순수 추론**: 키워드 매칭이나 규칙 기반 접근법을 사용하지 않는 100% AI 추론
- **자율적 임무 완수**: 사용자 목표 달성까지 AI가 독립적으로 도구 선택 및 실행

## 🎯 핵심 컴포넌트 및 기능

### 1. 장기기억 시스템 (RAG 기반)
- **행동 기록 저장**: "왜 그 행동을 했는지"와 "어떤 행동을 했는지"를 임베딩으로 저장
- **자동 중요도 판단**: AI가 스스로 정보의 중요도를 판단하여 기억할지 결정
- **관련 기억 검색**: 새로운 요청시 과거 관련 행동 패턴을 RAG로 검색
- **컨텍스트 종합**: 과거 행동 이유와 현재 요청을 종합하여 개인화된 판단

### 2. Discord Bot (원격 사용자 인터페이스)
- **모바일 접근성**: 사용자가 Mac 앞에 없어도 휴대폰으로 AI 비서와 소통
- **자연어 명령 중계**: CLI 백그라운드 프로세스에 명령을 전달하는 다리 역할
- **양방향 소통**: AI의 추가 정보 요청을 사용자에게 전달
- **결과 보고**: 최종 결과 및 진행 상황을 휴대폰으로 실시간 전달

### 3. 에이전틱 AI 엔진
- **순수 자연어 이해**: 키워드 매칭이나 분류 과정 없이 LLM이 직접 자연어를 이해
- **에이전틱 도구 선택**: 중간 단계 없이 자연어 → 도구 선택 직접 매핑
- **Chain of Thought 추론**: AI의 의사결정 과정을 투명하게 설명하고 검증
- **자율적 실행 계획**: JSON 기반 구조화된 실행 계획을 AI가 스스로 생성
- **높은 신뢰도**: 0.95+ 신뢰도로 정확한 도구 선택 달성
- **행동 패턴 학습**: 과거 "왜 그 행동을 했는지" 기록을 바탕으로 의사결정 개선
- **오류 처리**: 문제 발생시 스스로 문제를 파악하고 해결
- **임무 완수**: 사용자 목표 달성까지 자율적으로 반복 수행

### 4. MCP 도구 레이어
- **도구 실행**: AI가 선택한 도구들을 실제 실행
- **결과 피드백**: 실행 결과를 AI에게 피드백
- **외부 서비스 연동**: 다양한 외부 서비스 API 연동

### 5. CLI 백그라운드 프로세스 (핵심 엔진)
- **상시 실행**: Mac에서 24시간 백그라운드 데몬으로 실행
- **Discord 연결**: Discord Bot으로부터 명령을 받아 처리
- **시스템 통합**: AI 엔진, 장기기억, MCP 도구들을 통합 관리
- **로그 모니터링**: 실시간 작업 진행 상황 추적

## 🏗️ 시스템 아키텍처

```
사용자 ──자연어 명령──► Discord Bot ──명령 전달──► CLI 백그라운드 프로세스
                           ▲                              │
                           │                              ▼
                        추가정보 요청              ┌─ 장기기억 시스템 ◄─┐
                           │                    ▼   (RAG + 임베딩)    │
                        결과 피드백 ◄─────── 에이전틱 AI 엔진 ─────────┘
                                          (LLM + 자율판단 + 기억 활용)
                                                     │
                                                     ▼
                                              MCP 도구 레이어
                                              (도구 선택 & 실행)
                                                     ▲
                                                     │
                                              macOS 시스템 알림
                                              (능동적 트리거)
```

### 핵심 특징

1. **에이전틱 AI 방식**
   - **순수 LLM 추론**: 키워드 매칭이나 규칙 기반 분류를 사용하지 않음
   - **직접 매핑**: 자연어 → 도구 선택을 중간 단계 없이 바로 처리
   - **높은 신뢰도**: 0.95+ 신뢰도로 정확한 의사결정 달성
   - **투명성**: Chain of Thought로 AI의 추론 과정을 명확히 설명

2. **능동적 + 수동적 처리**
   - 수동적: 사용자 Discord 명령 대기
   - 능동적: macOS 시스템 알림 자동 감지 및 처리

3. **장기기억 활용**
   - 모든 상호작용을 "행동과 이유" 형태로 학습
   - 로그가 아닌 의사결정 패턴 저장으로 개인화된 서비스 제공

4. **원격 접근성**
   - Discord를 통해 사용자가 Mac 앞에 없어도 언제든 AI 비서 활용 가능

### 워크플로우

#### 사용자 명령 처리 (수동적)
1. **명령 접수**: 사용자가 Discord Bot에게 자연어로 명령 전송
2. **명령 전달**: Discord Bot이 CLI 백그라운드 프로세스에 자연어 그대로 전달
3. **기억 검색**: 에이전틱 AI가 장기기억에서 관련 과거 행동 패턴 RAG 검색
4. **에이전틱 분석**: AI가 과거 행동 이유와 현재 명령을 순수 추론으로 종합하여 도구 선택
5. **직접 실행**: 중간 분류 과정 없이 AI가 바로 적절한 MCP 도구들을 선택하고 실행
6. **행동 기록**: "왜 이 행동을 했는지"와 "어떤 행동을 했는지"를 장기기억에 저장
7. **추가 정보 수집**: 필요시 Discord Bot을 통해 사용자에게 추가 정보 요청
8. **오류 처리**: 문제 발생시 AI가 스스로 문제를 파악하고 해결 시도
9. **임무 완수**: 목표 달성시 즉시 종료, 미완료시 5-8단계를 자율적으로 반복
10. **결과 보고**: Discord Bot을 통해 최종 결과 보고

#### 시스템 알림 처리 (능동적)
1. **알림 감지**: macOS 시스템에서 새로운 알림 (문자, 메일 등) 감지
2. **에이전틱 분석**: AI가 알림 내용을 순수 자연어 처리로 분석
3. **스마트 판단**: 장기기억의 행동 패턴을 활용하여 알림의 중요도 및 필요한 액션 결정
4. **자동 액션**: 필요시 관련 MCP 도구를 자동 실행 (일정 추가, 할일 생성 등)
5. **사용자 알림**: Discord를 통해 처리 결과 보고

## 🛠️ MCP 도구 목록

*AI 비서가 자율적으로 선택하여 사용할 수 있는 도구들*

### 1. Notion 연동 도구 (우선순위 1)
**목적**: 개인 일정 및 할일 관리 자동화

- **캘린더 관리**: 일정 추가/수정/조회/삭제
- **할일 관리**: 할일 추가/완료/우선순위 설정/상태 조회
- **자연어 처리**: "내일 오후 3시 회의" → 구조화된 데이터 변환
- **기술**: Notion API, 날짜/시간 파싱

### 2. 지능형 웹 정보 수집 도구 (우선순위 2)
**목적**: 학회 공지사항 및 관심 분야 소식 자동 수집

- **AI 동적 크롤링**: HTML 구조 자동 분석 → 맞춤형 크롤링 코드 생성
- **정보 필터링**: 중요도 자동 판단, 중복 제거, 요약 생성
- **정기 모니터링**: 스케줄링을 통한 자동 업데이트 확인
- **기술**: Gemini 2.5 Pro HTML 분석, BeautifulSoup/Scrapy, RSS 파서

### 3. Apple 시스템 연동 도구 (우선순위 3)
**목적**: macOS 알림 자동 감지 및 지능형 처리

- **시스템 모니터링**: Messages, Mail, 캘린더 등 실시간 알림 감지
- **자동 액션**: 알림 내용 분석 후 관련 작업 자동 실행
- **컨텍스트 인식**: 장기기억의 행동 패턴을 활용한 개인화된 중요도 판단
- **기술**: 오픈소스 Apple MCP 서버, macOS API, 자연어 처리

### 개발 예정 도구들
*사용자가 요청하는 추가 기능에 따라 필요한 도구들을 추가합니다*

## 📋 개발 규칙

### API 에러 처리 원칙
- **풀백 금지**: API 호출 실패시 풀백 데이터를 사용하지 않음
- **명확한 에러 반환**: 모든 API 오류는 구체적인 에러 메시지와 함께 사용자에게 보고
- **투명한 실패 처리**: "API 연결 실패", "인증 오류", "서비스 응답 없음" 등 명확한 상태 전달
- **재시도 로직**: 일시적 오류의 경우 자동 재시도 후 최종 실패시 명확한 에러 보고
- **사용자 안내**: 문제 해결 방법이나 대안을 함께 제시

### 에러 보고 형식
```
❌ [도구명] 실행 실패
원인: [구체적인 오류 내용]
해결방법: [사용자가 취할 수 있는 조치]
```

예시:
```
❌ Notion 일정 추가 실패
원인: Notion API 인증 토큰이 만료되었습니다
해결방법: Notion 연동 설정을 다시 확인해주세요
```

## � 기술 스택

### Backend
- **언어**: Python 3.13+
- **CLI 프레임워크**: Click, Typer
- **Discord**: discord.py
- **에이전틱 AI**: Google Gemini 2.5 Pro API (순수 LLM 추론)
- **의사결정**: Chain of Thought, JSON 구조화 응답
- **MCP**: Model Context Protocol SDK
- **Notion**: Notion API (notion-client)
- **Apple**: Apple MCP Server (macOS 시스템 연동)
- **웹 크롤링**: BeautifulSoup4, Scrapy, Requests
- **RSS**: feedparser
- **데이터베이스**: SQLite (로컬) + ChromaDB (Vector DB)
- **프로세스 관리**: systemd (Linux/macOS)

### 개발 환경
- **패키지 관리**: Poetry
- **테스팅**: Pytest
- **로깅**: Rich, Loguru

## 📅 개선된 개발 로드맵

### 🎯 개발 전략
- **단계별 완전성**: 각 단계는 독립적으로 테스트 가능한 완성된 기능 단위
- **점진적 통합**: 이전 단계의 결과물을 기반으로 다음 단계 구축
- **AI 에이전트 친화적**: 명확한 입력/출력 정의로 자동화된 개발 가능

### 📊 Phase 1: 기반 인프라 구축

#### Step 1.1: 프로젝트 초기 설정
**목표**: 개발 환경 및 프로젝트 구조 설정

- Poetry 프로젝트 초기화
- 폴더 구조 생성
- `.gitignore`, `.env.example` 파일 생성
- 기본 의존성 패키지 정의 (pyproject.toml)

**산출물**: 실행 가능한 빈 프로젝트 구조  
**검증**: `poetry install` 성공 및 `python src/main.py` 실행 확인

#### Step 1.2: 로깅 시스템 구축
**목표**: 전체 시스템에서 사용할 로깅 인프라 구축

- Loguru 기반 로깅 설정
- 로그 레벨별 파일 분리 저장
- Rich 콘솔 출력 통합

**산출물**: `src/utils/logger.py` 모듈  
**검증**: 다양한 레벨의 로그 테스트 및 파일 생성 확인

#### Step 1.3: 환경 설정 관리 시스템
**목표**: 환경 변수 및 설정 관리 체계 구축

- Pydantic Settings 기반 설정 클래스
- `.env` 파일 자동 로드
- 설정 유효성 검증

**산출물**: `src/config.py` 모듈  
**검증**: 환경 변수 로드 및 유효성 검증 테스트

#### Step 1.4: CLI 기본 구조 구현
**목표**: Click 기반 CLI 명령어 체계 구축

- 메인 CLI 그룹 생성
- 기본 명령어 구조 (`start`, `stop`, `status`)
- 데몬 모드 실행 기능

**산출물**: `src/cli/` 디렉토리 및 기본 명령어  
**검증**: `python src/main.py --help` 및 각 명령어 실행 테스트

#### Step 1.5: 백그라운드 프로세스 관리
**목표**: 데몬 프로세스 생명주기 관리

- PID 파일 기반 프로세스 관리
- 시그널 핸들링 (SIGTERM, SIGINT)
- 자동 재시작 메커니즘

**산출물**: `src/daemon.py` 모듈  
**검증**: 프로세스 시작/중지/상태 확인 테스트
### 📊 Phase 2: Discord 통신 레이어

#### Step 2.1: Discord Bot 기본 구현
**목표**: Discord Bot 기본 연결 및 이벤트 처리

- discord.py 기반 봇 클래스
- 기본 이벤트 핸들러 (on_ready, on_message)
- 연결 상태 관리

**산출물**: `src/discord_bot/bot.py`  
**검증**: Discord 서버 연결 및 메시지 수신 확인

#### Step 2.2: 명령어 파싱 시스템
**목표**: 자연어 명령을 구조화된 데이터로 변환

- 명령어 라우터 구현
- 멘션/DM 구분 처리
- 기본 명령어 응답 (`!help`, `!status`)

**산출물**: `src/discord_bot/commands.py`  
**검증**: 다양한 명령어 형식 테스트

#### Step 2.3: 메시지 큐 시스템
**목표**: Discord와 백엔드 간 비동기 통신

- asyncio 기반 메시지 큐
- 요청/응답 매칭 시스템
- 타임아웃 처리

**산출물**: `src/discord_bot/message_queue.py`  
**검증**: 동시 다발적 메시지 처리 테스트

#### Step 2.4: 대화 세션 관리
**목표**: 사용자별 대화 컨텍스트 유지

- 사용자 ID 기반 세션 관리
- 대화 히스토리 저장
- 세션 타임아웃 처리

**산출물**: `src/discord_bot/session.py`  
**검증**: 다중 사용자 동시 대화 테스트
### 📊 Phase 3: 에이전틱 AI 엔진 핵심

#### Step 3.1: LLM 프로바이더 추상화
**목표**: Gemini 2.5 Pro 기반 통합 인터페이스

- Google Gemini 2.5 Pro API 래퍼
- 공통 인터페이스 정의
- 자동 프로바이더 선택 로직

**산출물**: `src/ai_engine/llm_provider.py`  
**검증**: Gemini API 호출 테스트

#### Step 3.2: 프롬프트 관리 시스템
**목표**: 체계적인 프롬프트 템플릿 관리

- 프롬프트 템플릿 저장 구조
- 동적 변수 치환 시스템
- 프롬프트 버전 관리

**산출물**: `src/ai_engine/prompts/` 디렉토리  
**검증**: 다양한 시나리오별 프롬프트 생성 테스트


#### Step 3.3: 에이전틱 의사결정 엔진
**목표**: LLM이 직접 자연어를 이해하고 도구를 선택하는 진정한 AI 에이전트 구현

- 순수 LLM 기반 자연어 이해 (키워드 매칭 제거)
- 에이전틱 도구 선택 (구시대적 분류 단계 제거)
- Chain of Thought 추론으로 의사결정 과정 투명화
- JSON 기반 구조화된 실행 계획 생성
- 높은 신뢰도 스코어링 시스템 (0.95+ 달성)

**산출물**: `src/ai_engine/decision_engine.py` (AgenticDecisionEngine)  
**검증**: 자연어 → 도구 선택 직접 매핑 테스트

#### Step 3.4: 작업 계획 수립 시스템
**목표**: 복잡한 작업을 단계별로 분해

- 작업 분해 알고리즘
- 의존성 그래프 생성
- 실행 순서 최적화

**산출물**: `src/ai_engine/task_planner.py`  
**검증**: 복잡한 명령어 분해 테스트
### 📊 Phase 4: 장기기억 시스템

#### Step 4.1: 벡터 데이터베이스 설정
**목표**: ChromaDB 기반 벡터 저장소 구축

- ChromaDB 초기화 및 컬렉션 생성
- 임베딩 모델 통합
- 인덱싱 최적화

**산출물**: `src/memory/vector_store.py`  
**검증**: 벡터 저장/검색 성능 테스트

#### Step 4.2: 기억 구조 정의 ✅ **완료 (2025-01-03)**
**목표**: 체계적인 기억 데이터 모델

- ✅ 행동-이유 페어 데이터 모델 (ActionReasoningPair)
- ✅ 메타데이터 스키마 정의 (MetadataSchema) 
- ✅ 중요도 점수 체계 (ImportanceCalculator)
- ✅ 자동 태그/키워드 추출
- ✅ 기억 생명주기 관리 (아카이빙/삭제 조건)
- ✅ 스키마 검증 시스템

**산출물**: `src/memory/enhanced_models.py`  
**검증**: 전체 기억 모델 테스트 완료 (100% 성공)

#### Step 4.3: RAG 검색 엔진 ✅ **완료 (2025-01-03)**
**목표**: 지능형 기억 검색 시스템

- ✅ 의미적 유사도 검색 (ChromaDB 벡터 검색)
- ✅ 하이브리드 검색 (키워드 + 벡터)
- ✅ 검색 결과 랭킹 알고리즘 (5가지 전략)
- ✅ BM25 키워드 검색 엔진
- ✅ 고급 필터링 시스템
- ✅ 다양한 검색 모드 (SEMANTIC, KEYWORD, HYBRID, CONTEXTUAL)
- ✅ 성능 최적화 (50개 문서 0.000초 인덱싱)

**산출물**: `src/memory/rag_engine.py`  
**검증**: 검색 정확도 및 성능 테스트 완료 (100% 성공)

#### Step 4.4: 기억 관리 시스템 ✅ **완료 (2025-01-03)**
**목표**: 기억 생명주기 관리

- ✅ 자동 중요도 판단 (접근 빈도, 최근성, 복잡도, 기본 중요도 기반)
- ✅ 기억 압축 및 요약 (LLM 요약, 핵심 포인트 추출)
- ✅ 오래된 기억 아카이빙 (연령, 중요도 기반 자동 아카이빙)
- ✅ 스토리지 용량 관리 (최대 활성 기억 수 제한)
- ✅ 기억 생명주기 관리 (생성 → 압축 → 아카이빙)
- ✅ 통계 및 모니터링 시스템

**산출물**: `src/memory/simple_memory_manager.py`  
**검증**: 장기 운영 시뮬레이션 테스트 완료 (100% 성공)
### 📊 Phase 5: MCP 프로토콜 구현

#### Step 5.1: MCP 기본 프로토콜
**목표**: MCP 통신 프로토콜 구현

- JSON-RPC 메시지 처리
- 요청/응답 핸들링
- 에러 처리 표준화

**산출물**: `src/mcp/protocol.py`  
**검증**: 프로토콜 준수 테스트

#### Step 5.2: 도구 레지스트리
**목표**: 동적 도구 관리 시스템

- 도구 자동 발견 및 등록
- 도구 메타데이터 관리
- 도구 버전 관리

**산출물**: `src/mcp/registry.py`  
**검증**: 도구 등록/해제 테스트

#### Step 5.3: 도구 실행 엔진
**목표**: 안전한 도구 실행 환경

- 샌드박스 실행 환경
- 타임아웃 및 리소스 제한
- 실행 결과 검증

**산출물**: `src/mcp/executor.py`  
**검증**: 다양한 도구 실행 시나리오 테스트

#### Step 5.4: 도구 인터페이스 추상화
**목표**: 통일된 도구 인터페이스

- 기본 도구 클래스 정의
- 입력/출력 스키마 검증
- 도구 설명 표준화

**산출물**: `src/mcp/base_tool.py`  
**검증**: 도구 인터페이스 준수 테스트
### 📊 Phase 6: Notion 연동 도구

#### Step 6.1: Notion API 클라이언트 ✅
**목표**: Notion API 통신 레이어

- API 인증 처리
- 요청 속도 제한 관리
- 에러 재시도 로직
- MCP 도구 인터페이스 구현
- CLI 명령어 인터페이스

**산출물**: 
- `src/tools/notion/client.py` ✅
- `src/tools/notion/calendar_tool.py` ✅
- `src/tools/notion/todo_tool.py` ✅
- `src/cli/main.py` (Notion 명령어 추가) ✅
- `NOTION_SETUP.md` (설정 가이드) ✅

**검증**: API 연결 및 인증 테스트, CLI 명령어 실행 테스트 ✅

#### Step 6.2: 데이터베이스 스키마 매핑
**목표**: Notion 데이터베이스 구조 매핑

- 캘린더 데이터베이스 스키마
- 할일 데이터베이스 스키마
- 필드 타입 변환기

**산출물**: `src/tools/notion/schemas.py`  
**검증**: 데이터 변환 정확성 테스트

#### Step 6.3: 자연어 파싱 엔진
**목표**: 자연어를 구조화된 데이터로 변환

- 날짜/시간 표현 파싱
- 반복 일정 패턴 인식
- 우선순위 키워드 추출

**산출물**: `src/tools/notion/nlp_parser.py`  
**검증**: 다양한 자연어 입력 테스트

#### Step 6.4: CRUD 작업 구현
**목표**: 완전한 Notion 데이터 조작

- 일정 추가/수정/삭제/조회
- 할일 추가/완료/우선순위 변경
- 벌크 작업 최적화

**산출물**: `src/tools/notion/operations.py`  
**검증**: 전체 CRUD 시나리오 테스트
### 📊 Phase 7: 웹 정보 수집 도구

#### Step 7.1: HTML 구조 분석 AI
**목표**: Gemini 2.5 Pro 기반 HTML 이해 시스템

- DOM 트리 분석
- 콘텐츠 영역 자동 식별
- 메타데이터 추출

**산출물**: `src/tools/web_scraper/html_analyzer.py`  
**검증**: 다양한 웹사이트 구조 분석 테스트

#### Step 7.2: 동적 크롤러 생성기
**목표**: 사이트별 맞춤 크롤러 자동 생성

- 크롤링 코드 템플릿 생성
- 선택자 자동 생성
- 페이지네이션 처리

**산출물**: `src/tools/web_scraper/crawler_generator.py`  
**검증**: 생성된 크롤러 실행 테스트

#### Step 7.3: 코드 안전성 검증
**목표**: 생성된 코드의 안전성 보장

- 정적 코드 분석
- 샌드박스 실행 테스트
- 리소스 사용량 모니터링

**산출물**: `src/tools/web_scraper/code_validator.py`  
**검증**: 악의적 코드 탐지 테스트

#### Step 7.4: 스케줄링 시스템
**목표**: 정기적 정보 수집 자동화

- 크론 스타일 스케줄링
- 변경 감지 알고리즘
- 알림 트리거 설정

**산출물**: `src/tools/web_scraper/scheduler.py`  
**검증**: 장기 스케줄링 안정성 테스트
### 📊 Phase 8: Apple 시스템 연동 (외부 오픈소스 활용)

> **📌 외부 리소스 활용**: [supermemoryai/apple-mcp](https://github.com/supermemoryai/apple-mcp) (2.4k stars, MIT License)  
> **전략**: 성숙한 오픈소스 Apple MCP 서버를 Python 클라이언트로 연동하여 개발 시간 단축 및 안정성 확보

#### Step 8.1: Apple MCP 서버 설치 및 설정
**목표**: 외부 TypeScript Apple MCP 서버 연동 환경 구축

**완료된 작업:**
- [x] **외부 리포지토리 분석 완료** 
  - supermemoryai/apple-mcp 기능 분석
  - 8개 Apple 앱 지원 확인 (Messages, Notes, Contacts, Mail, Reminders, Calendar, Maps, Web Search)
  - TypeScript + Bun 런타임 아키텍처 파악
  - MCP 프로토콜 호환성 검증

**계획된 작업:**
- [ ] **Apple MCP 서버 로컬 설치**
  ```bash
  # Smithery를 통한 간편 설치
  npx -y install-mcp apple-mcp --client claude
  
  # 또는 소스코드 직접 설치
  git clone https://github.com/supermemoryai/apple-mcp.git
  cd apple-mcp && bun install && bun run index.ts
  ```
- [ ] **macOS 권한 설정**
  - System Settings > Privacy & Security > Automation 설정
  - 각 Apple 앱별 접근 권한 부여
  - 권한 확인 스크립트 작성
- [ ] **연결 테스트 및 검증**
  - JSON-RPC 통신 테스트
  - 각 Apple 앱별 기본 기능 테스트

**산출물**: 
- `docs/apple-mcp-setup.md` - 설치 및 설정 가이드
- `scripts/setup-apple-permissions.sh` - 권한 설정 자동화 스크립트  
**검증**: Apple MCP 서버 정상 작동 및 모든 앱 연동 확인

#### Step 8.2: Python MCP 클라이언트 구현
**목표**: TypeScript Apple MCP 서버와 Python 간 통신 브리지 구축

**계획된 작업:**
- [ ] **JSON-RPC 클라이언트 구현**
  - 비동기 통신 지원 (asyncio)
  - 요청/응답 매핑 및 타임아웃 처리
  - 연결 풀 관리 및 재연결 로직
  
- [ ] **Apple MCP 클라이언트 래퍼**
  ```python
  # src/tools/apple/mcp_client.py
  class AppleMCPClient:
      async def call_tool(self, tool_name: str, args: dict) -> dict
      async def list_tools(self) -> List[Tool]
      async def check_health(self) -> bool
  ```

- [ ] **8개 Apple 앱별 도구 래퍼**
  - `MessagesClient` - 메시지 전송/읽기/예약
  - `NotesClient` - 노트 생성/검색/관리
  - `ContactsClient` - 연락처 검색/조회
  - `MailClient` - 메일 전송/검색/관리
  - `RemindersClient` - 미리 알림 생성/관리
  - `CalendarClient` - 이벤트 생성/검색/관리
  - `MapsClient` - 위치 검색/저장/길찾기
  - `WebSearchClient` - Safari 기반 웹 검색

- [ ] **MCP 도구 표준화**
  - 기존 MCP BaseTool 인터페이스 준수
  - 통합 오류 처리 및 로깅
  - 도구 메타데이터 자동 생성

**산출물**: 
- `src/tools/apple/mcp_client.py` - 핵심 클라이언트
- `src/tools/apple/` 디렉토리 - 각 앱별 래퍼 클래스  
**검증**: Python에서 모든 Apple 앱 기능 정상 호출 확인

#### Step 8.3: 에이전틱 AI와 Apple 기능 통합
**목표**: 자연어 명령을 Apple 앱 작업으로 자동 실행하는 에이전틱 파이프라인 구축

**계획된 작업:**
- [ ] **Apple 도구 자동 등록**
  - 기존 도구 레지스트리에 Apple 도구들 추가
  - 동적 도구 발견 및 메타데이터 추출
  
- [ ] **자연어 → Apple 작업 매핑**
  ```python
  # 예시 자연어 명령들
  "어머니께 늦는다고 메시지 보내줘"
  "오늘 일정 확인해줘"
  "회의 노트를 찾아서 팀장님께 메일로 보내줘"
  "내일 오후 3시에 치과 예약 미리 알림 만들어줘"
  "강남역 근처 맛집 찾아서 즐겨찾기에 저장해줘"
  ```

- [ ] **체인 명령 지원**
  - 복수 Apple 앱 연계 작업 자동화
  - 예: "회의 노트 찾기 → 참석자 연락처 검색 → 감사 메시지 전송"
  - 중간 단계 확인 및 오류 처리

- [ ] **컨텍스트 인식 작업**
  - 장기기억에서 관련 정보 검색
  - 사용자 선호도 및 패턴 학습
  - 개인화된 Apple 앱 사용법 제안

**산출물**: 
- `src/ai_engine/apple_integration.py` - Apple 앱 에이전틱 통합  
- `src/tools/apple/chain_executor.py` - 체인 명령 실행기  
**검증**: 복잡한 자연어 명령을 Apple 앱 체인 작업으로 성공적 실행

#### Step 8.4: 시스템 알림 모니터링 및 자동 응답
**목표**: macOS 시스템 알림을 실시간 감지하고 AI가 자동으로 적절한 대응 수행

**계획된 작업:**
- [ ] **알림 모니터링 시스템**
  - macOS Notification Center 실시간 모니터링
  - 앱별 알림 분류 및 필터링
  - 중요도 자동 판단 (긴급/일반/스팸)

- [ ] **지능형 알림 분석**
  ```python
  # 알림 예시들
  "새 메시지: 회의 시간이 변경되었습니다"
  "새 메일: 프로젝트 승인 요청"
  "캘린더: 10분 후 미팅이 있습니다"
  ```
  - 알림 내용 자연어 분석
  - 행동 필요성 판단 (응답/일정수정/메모생성 등)
  - 관련 컨텍스트 검색 (과거 대화, 일정, 연락처 등)

- [ ] **자동 액션 실행**
  - 알림 → 에이전틱 AI 분석 → 적절한 Apple 앱 액션 자동 실행
  - 예: 회의 일정 변경 알림 → 캘린더 수정 + 참석자들에게 알림 메시지
  - 사용자 확인 후 실행 또는 자동 실행 (설정 가능)

- [ ] **Discord 알림 연동**
  - 중요한 시스템 알림을 Discord로 전달
  - 원격에서도 AI 비서 통해 대응 가능
  - 알림 처리 결과 피드백

**산출물**: 
- `src/tools/apple/notification_monitor.py` - 알림 모니터링  
- `src/tools/apple/auto_responder.py` - 자동 응답 시스템  
**검증**: 다양한 시스템 알림에 대한 자동 대응 시나리오 테스트

### 🔧 **Apple MCP 통합 기술 스택**

**외부 의존성:**
- **Apple MCP 서버**: TypeScript + Bun + AppleScript/JXA
- **Node.js/Bun**: Apple MCP 서버 실행 환경
- **macOS 권한**: System Settings > Privacy & Security > Automation

**Python 통합 레이어:**
- **JSON-RPC 클라이언트**: `asyncio` + `aiohttp`
- **MCP 프로토콜 브리지**: 기존 MCP 인프라와 호환
- **Apple 앱 래퍼**: 각 앱별 Python 인터페이스

### 📈 **Phase 8 성공 지표**
- ✅ Apple MCP 서버 정상 설치 및 실행
- ✅ 8개 Apple 앱 모든 기능 Python에서 호출 가능
- ✅ 자연어 → Apple 앱 작업 자동 실행 (신뢰도 0.95+)
- ✅ 체인 명령 3단계 이상 연계 작업 성공
- ✅ 시스템 알림 자동 감지 및 대응 (응답시간 5초 이내)
- ✅ Discord 원격 제어로 Apple 앱 작업 실행

### 💡 **외부 오픈소스 활용의 장점**
1. **개발 시간 단축**: AppleScript/JXA 복잡한 구현을 건너뛰고 검증된 코드 활용
2. **안정성 확보**: 2.4k stars, 활발한 커뮤니티, 지속적 업데이트
3. **기능 완성도**: 8개 Apple 앱 + 웹 검색까지 포괄적 지원
4. **호환성 보장**: 표준 MCP 프로토콜 준수로 향후 확장성 확보
5. **유지보수 효율**: 외부 서버 업데이트 시 자동으로 기능 개선 혜택
### 📊 Phase 9: 통합 및 최적화

#### Step 9.1: 컴포넌트 통합
**목표**: 모든 모듈의 유기적 연결

- 모듈 간 인터페이스 정의
- 이벤트 버스 구현
- 의존성 주입 설정

**산출물**: `src/integration/` 디렉토리  
**검증**: 전체 워크플로우 통합 테스트

#### Step 9.2: 에러 처리 고도화
**목표**: 강력한 에러 복구 시스템

- 전역 에러 핸들러
- 재시도 전략 구현
- 에러 보고 시스템

**산출물**: `src/utils/error_handler.py`  
**검증**: 다양한 실패 시나리오 테스트

#### Step 9.3: 성능 최적화
**목표**: 시스템 응답속도 개선

- 비동기 처리 최적화
- 캐싱 전략 구현
- 리소스 풀 관리

**산출물**: 최적화된 코드베이스  
**검증**: 부하 테스트 및 벤치마킹

#### Step 9.4: 모니터링 대시보드
**목표**: 시스템 상태 실시간 모니터링

- 메트릭 수집 시스템
- 웹 기반 대시보드
- 알림 임계값 설정

**산출물**: `src/monitoring/` 디렉토리  
**검증**: 대시보드 기능 테스트
### 📊 Phase 10: 배포 준비

#### Step 10.1: 자동화 테스트 스위트
**목표**: 완전한 테스트 커버리지

- 단위 테스트 작성
- 통합 테스트 작성
- E2E 테스트 시나리오

**산출물**: `tests/` 디렉토리 완성  
**검증**: 테스트 커버리지 80% 이상

#### Step 10.2: 문서화
**목표**: 완전한 프로젝트 문서

- API 문서 자동 생성
- 사용자 가이드 작성
- 개발자 문서 작성

**산출물**: `docs/` 디렉토리  
**검증**: 문서 완성도 검토

#### Step 10.3: 배포 자동화
**목표**: 원클릭 배포 시스템

- 설치 스크립트 작성
- systemd 서비스 설정
- 업데이트 메커니즘

**산출물**: `scripts/` 디렉토리  
**검증**: 클린 환경 배포 테스트

#### Step 10.4: 보안 감사
**목표**: 보안 취약점 제거

- 의존성 취약점 스캔
- 코드 보안 분석
- 권한 최소화 검증

**산출물**: 보안 감사 보고서  
**검증**: 보안 체크리스트 통과

## 🚨 예상 문제점 및 대응 방안

### 1. API 제한 및 비용 관리
**문제**: Gemini API 호출 비용 관리  
**대응**:
- 응답 캐싱 시스템 구현
- 토큰 사용량 모니터링
- 일일 한도 설정 기능

### 2. 비동기 처리 복잡성
**문제**: 데드락, 레이스 컨디션  
**대응**:
- asyncio 전문 디버깅 도구 사용
- 명확한 락 계층 구조 정의
- 타임아웃 기반 데드락 감지

### 3. 메모리 누수
**문제**: 장기 실행시 메모리 증가  
**대응**:
- 정기적 가비지 컬렉션
- 메모리 프로파일링 도구 통합
- 자동 재시작 메커니즘

### 4. macOS 권한 문제
**문제**: 시스템 API 접근 제한  
**대응**:
- 명확한 권한 요청 가이드
- 대체 API 경로 준비
- 권한 에스컬레이션 최소화

### 5. 네트워크 불안정성
**문제**: Discord/API 연결 끊김  
**대응**:
- 지수 백오프 재연결
- 오프라인 작업 큐
- 연결 상태 헬스체크

### 6. 데이터 일관성
**문제**: 분산 컴포넌트 간 데이터 불일치  
**대응**:
- 트랜잭션 로그 구현
- 이벤트 소싱 패턴
- 정기적 일관성 검증

## 📈 성공 지표

각 단계별 완료 기준:
- **코드 커버리지**: 80% 이상
- **응답 시간**: 평균 2초 이내
- **에러율**: 1% 미만
- **메모리 사용량**: 500MB 이하
- **동시 사용자**: 10명 이상 지원

---

*이 로드맵은 AI 에이전트가 순차적으로 실행할 수 있도록 설계되었으며, 각 단계는 명확한 입력과 출력을 가지고 있습니다.*

## 📁 프로젝트 구조

```
Personal-AI-Assistant/
├── README.md
├── PROJECT_PLAN.md
├── requirements.txt
├── pyproject.toml
├── .env.example
│
├── src/
│   ├── main.py                 # CLI 메인 엔트리포인트
│   ├── cli/                    # CLI 명령어 정의
│   ├── discord_bot/            # Discord Bot 구현
│   ├── ai_engine/              # AI 비서 엔진
│   ├── memory/                 # 장기기억 시스템 (RAG + 임베딩)
│   ├── mcp/                    # MCP 프로토콜 구현
│   ├── tools/                  # MCP 도구들
│   ├── automation/             # 자동화 시스템
│   ├── data/                   # 데이터 관리 (SQLite)
│   └── utils/                  # 유틸리티 함수
│
├── tests/                      # 테스트
├── logs/                       # 로그 파일
└── data/                       # 로컬 데이터베이스 파일
```

---

*이 문서는 프로젝트 진행에 따라 지속적으로 업데이트됩니다.*
